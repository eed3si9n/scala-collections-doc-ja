<html dir="ltr"> <head>
<title>Scala 2.8 コレクション API</title>

<style type="text/css">.maketitle {
  /* align: center; */
}
div.abstract {
  margin-left: 20%;
  margin-right: 10%;
}
h3.abstract {
  /* align: center; */
}
div.verse, div.quote, div.quotation {
  margin-left: 10%;
  margin-right: 10%;
}
</style>


</head> <body dir="ltr">
<h1 class="maketitle">Scala 2.8 コレクション API</h1>
<h2 class="maketitle">Martin Odersky, Lex Spoon</h2>
<h3 class="maketitle">2010 年 9 月 7 日</h3>
<p>新しいコレクションフレームワークは Scala 2.8 で最も重要な変更だと多くの人が思っている．以前の Scala にもコレクションはあった (大部分において新しいフレームワークは旧版と互換性がある)．しかし，Scala 2.8 になって共通，一様，かつ包括的なコレクション型のフレームワークを提供することができた．<p>コレクションへの追加は、一見すると微細なものだが、あなたのプログラミングスタイルに深い影響与えうるものだ．コレクションの一要素ではなくコレクション全体を基本的なビルディングブロックとすることで，あたかも一つ上の階層でプログラミングをしているかのように感じることが頻繁にある．この新しいプログラミングスタイルには慣れを必要とすることもあるが，幸い新しいコレクションの特長のお陰で楽に適合できるようになっている．新しいコレクションは簡単に使えて，短く書けて，安全，高速で，統一性がある．
<p><b>簡単に使える</b> <br> <br>
20〜50 メソッドの小さな語彙を二三個組み合わせることで，ほとんどのコレクションの問題を解決することができる．複雑なループ構造や再帰に頭を悩ませる必要はない．永続的なコレクションと副作用のない操作は，既存のコレクションを間違って新しいデータで壊してしまう心配をする必要がないことを意味する．イテレータとコレクションの更新の間の干渉は完全になくなった．
<p><b>短く書ける</b><br> <br>
一つまたは複数のループが必要だった作業を単語一つで実現することができる．関数型の演算もライトウェイトな構文で表現でき，簡単に演算を組み合わせることでカスタム代数を扱っているかのように感じるはずだ．
<p><b>安全である</b><br> <br>
これは実際に経験してみないと分からないだろう．静的型付きでかつ関数型という Scala のコレクションの特徴は、可能なエラーの圧倒的多数はコンパイル時にキャッチされることを意味する．その理由は、（1）コレクションの演算はが大量に使用されているため、十分にテスト済みである． （2）コレクション演算を使うことで，インプットとアウトプットが関数のパラメータと結果という形で明示的になる．（3）これらの明示的なインプットとアウトプットは静的な型チェックの対象だ．結論としては，誤用の大多数が型エラーとして表出するということだ．数百行のプログラムが初回の一発で実行できることは決して稀ではない．
<p><b>速い</b> <br> <br>
コレクション演算はライブラリの中で調整され最適化されている．その結果，コレクションを使用することは一般的にかなり効率的だ．手作業で丁寧に調整されたデータ構造と演算により多少高速化することができるかもしれないが，不適切な実装上の決断を途中でしてしまうとかなり遅くなってしまうということもありえる．さらに、現在コレクションはマルチコア上での並列実行に適応されている途中だ．並列コレクションは順列コレクションと同じ演算をサポートするため，新しい演算を習ったりコードを書き変えたりする必要はない．<tt>par</tt> メソッドを呼ぶだけで順列コレクションを並列に変えることができる．
<p><b>統一性がある</b><br> <br>
コレクションは出来る限りどの型にも同じ演算を提供している．これにより，少ない語彙の演算でも多くのことができる．例えば、文字列は概念的には文字の列 (sequence) だ．その結果，Scalaのコレクションでは，文字列は列の演算の全てをサポートする．配列に関しても同様だ．
<p><b>例</b> <br> <br>
これは Scala のコレクションの多くの利点を示す一行コードだ．
<div class="quote"><p><tt></tt><table cellspacing="1" cellpadding="0"><tt></tt><tr><tt> </tt><td colspan="99" align="left"><tt><font color="#0000e5">val</font>  (minors, adults) = people partition (_.age &lt; <font color="#000000">18</font>)</tt></td></tr></table><tt> </tt></p></div>この演算が何をしているかは一目瞭然だ: <tt>people</tt> のコレクションを年齢によって <tt>minors</tt> と  <tt>adult</tt> に分割している．<tt>partition</tt> メソッドはコレクションの基底型である <tt>TraversableLike</tt> で定義されているため，このコードは配列を含むどのコレクションでも動作する．これによって生じる <tt>minors</tt> と <tt>adult</tt> のコレクションは，<tt>people</tt>コレクションと同じ型となる．
<p>このコードは，従来の 1〜3個のループを用いたコレクション処理に比べて，より簡潔なものになっている (中間結果をどこかにバッファリングする必要があるため，配列を用いた場合はループ3個)．基本的なコレクションの語彙を学んでしまえば，明示的なループを書くよりも，このようなコードを書く方が簡単かつ安全だと思うようになるだろう．さらに，<tt>partition</tt> 演算は高速であり，将来的にはマルチコア上で並列コレクションにかけると更に速くなるだろう．(並列コレクションは開発ビルドに入っており，Scala 2.9 の一部としてリリースされる予定．)
<p>以下のページは，ユーザーの視点から Scala 2.8 のコレクションクラスの API について詳細に説明する．全ての基本的なクラスと，そのメソッドについて案内してくれるはずだ．
<p>次:<ul>
<li><a href="collections_1.html">可変コレクションおよび不変コレクション</a>
<li><a href="collections_2.html">コレクション API の概要</a>
<li><a href="collections_3.html"><tt>Traversable</tt> トレイト</a>
<li><a href="collections_4.html"><tt>Iterable</tt> トレイト</a>
<li><a href="collections_5.html">列トレイト <tt>Seq, IndexedSeq, </tt>および<tt> LinearSeq</tt></a>
<li><a href="collections_7.html">集合</a>
<li><a href="collections_10.html">マップ</a>
<li><a href="collections_12.html">具象不変コレクションクラス</a>
<li><a href="collections_23.html">具象可変コレクションクラス</a>
<li><a href="collections_38.html">配列</a>
<li><a href="collections_39.html">文字列</a>
<li><a href="collections_40.html">性能特性</a>
<li><a href="collections_41.html">等価性</a>
<li><a href="collections_42.html">ビュー</a>
<li><a href="collections_43.html">イテレータ</a>
<li><a href="collections_45.html">コレクションの作成</a>
<li><a href="collections_46.html">Java と Scala 間のコレクションの変換</a>
<li><a href="collections_47.html">Scala 2.7 からの移行</a>
<li><a href="collections_48.html">謝辞</a>
<li><a href="collections_49.html">目次</a>
<li><a href="collections_50.html">脚注</a>
<li><a href="collections_toc.html">ナビゲーション</a>
</ul> <hr>
</p>
</body></html>
