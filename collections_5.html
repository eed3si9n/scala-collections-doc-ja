<html dir="ltr"> <head>
<title>Scala 2.8 コレクション API -- シーケンスの trait Seq, IndexedSeq, および LinearSeq</title>

<style type="text/css">.maketitle {
  /* align: center; */
}
div.abstract {
  margin-left: 20%;
  margin-right: 10%;
}
h3.abstract {
  /* align: center; */
}
div.verse, div.quote, div.quotation {
  margin-left: 10%;
  margin-right: 10%;
}
</style>


</head>
<body dir="ltr">
<table width="100%" cellpadding="0" cellspacing="2"><tr> <td bgcolor="#99ccff"><a href="collections_7.html"><img border="0" alt="Set" src="http://lampwww.epfl.ch/~odersky/images/next.png"></a></td><td bgcolor="#99ccff"><a href="collections_0.html"><img border="0" alt="トップ" src="http://lampwww.epfl.ch/~odersky/images/up.png"></a></td><td bgcolor="#99ccff"><a href="collections_4.html"><img border="0" alt="Trait Iterable" src="http://lampwww.epfl.ch/~odersky/images/previous.png"></a></td><td align="center" bgcolor="#99ccff" width="100%"><b>シーケンスの trait Seq, IndexedSeq, および LinearSeq</b></td><td bgcolor="#99ccff" align="center"><a href="collections_49.html">目次</a></td></tr></table>
<h1>シーケンスの trait Seq, IndexedSeq, および LinearSeq</h1> 
<p>trait <a href="http://www.scala-lang.org/api/current/scala/collection/Seq.html">Seq</a> はシーケンスを表す．シーケンスとは長さ (<tt>length</tt>) があり，それぞれの要素に <tt>0</tt> から数えられた固定された添字 (index) がある iterable の一種だ．<p><a href="collections_5.html#tab:seqops">以下の表</a>にまとめられたシーケンスの演算は以下のカテゴリーに分けることができる:<ul>
<li><em>添字と長さの</em>演算 <tt>apply</tt>, <tt>isDefinedAt</tt>, <tt>length</tt>, <tt>indices</tt>, および <tt>lengthCompare</tt>． <tt>Seq</tt> では <tt>apply</tt> メソッドは添字の意味で使われるため，<tt>Seq[T]</tt>型のシーケンスは  <tt>Int</tt> を引数 (添字) としてをとり，<tt>T</tt>型の要素を返す部分関数だ．つまり，<tt>Seq[T]</tt> は <tt>PartialFunction[Int,</tt> <tt>T]</tt> を継承する．シーケンス内の要素はゼロからシーケンスの長さ (<tt>length</tt>) − 1 まで添字付けられている．シーケンスの <tt>length</tt> メソッドは一般コレクションにおける <tt>size</tt> メソッドの別名だ．<tt>lengthCompare</tt> メソッドは，たとえどちらかのシーケンスが無限の長さを持っていても，二つのシーケンスの長さを比較することができる．
<li><em>添字検索演算</em>である <tt>indexOf</tt>, <tt>lastIndexOf</tt>, <tt>indexofSlice</tt>, <tt>lastIndexOfSlice</tt>, <tt>indexWhere</tt>, <tt>lastIndexWhere</tt>, <tt>segmentLength</tt>, <tt>prefixLength</tt> は，渡された値もしくは条件関数に合致する要素の添字を返す．
<li><em>加算</em>である <tt>+:</tt>, <tt>:+</tt>, <tt>padTo</tt> は，シーケンスの先頭か最後に要素を追加した新しいシーケンスを返す．
<li><em>更新演算</em>である <tt>updated</tt>, <tt>patch</tt> は，元のシーケンスに何らかの要素を上書きしたシーケンスを返す．<li><em>並べ替え演算</em>である <tt>sorted</tt>, <tt>sortWith</tt>, <tt>sortBy</tt> は，シーケンス内の要素を何らかの基準に基づいて並べ替える．
<li><em>逆転演算</em>である <tt>reverse</tt>, <tt>reverseIterator</tt>, <tt>reverseMap</tt> は，シーケンス内の要素を逆順に返すか処理する．
<li><em>比較演算</em>である <tt>startsWith</tt>, <tt>endsWith</tt>, <tt>contains</tt>, <tt>containsSlice</tt>, <tt>corresponds</tt> は，二つのシーケンスを関連付けるか，シーケンスの中から要素を検索する．<li><em>集合演算</em>である <tt>intersect</tt>, <tt>diff</tt>, <tt>union</tt>, <tt>distinct</tt> は，二つのシーケンス間で集合演算のようなものを行うか，シーケンス内の要素の重複を削除する．</ul>
シーケンスが可変の場合は，追加で副作用のある <tt>update</tt> メソッドを提供し，シーケンス内の要素を上書きすることができる． Scala の他の構文の例にならって，<tt>seq(idx)</tt> <tt>=</tt> <tt>elem</tt> は <tt>seq.update(idx,</tt> <tt>elem)</tt> の略記法であるため，<tt>update</tt> によって便利な代入構文がただで手に入る．<tt>update</tt> と <tt>updated</tt> の違いに注意してほしい． <tt>update</tt> はシーケンス内の要素を上書きし，可変シーケンスでのみ使用可能だ．<tt>updated</tt> は全てのシーケンスで使用可能であり，元のシーケンスは変更せずに常に新しいシーケンスを返す．

<table border=""><tbody>
<tr><td colspan="1" align="left"> <div align="center"><b><a href="http://www.scala-lang.org/api/current/scala/collection/Seq.html">Seq</a> クラスの演算<a name="id1"> </a></b></div><a name="tab:seqops"> </a></td></tr> 
<tr><td colspan="1" align="left"> <p><b>使用例</b> </p></td><td colspan="1" align="left"> <b>振る舞い</b> </td></tr> 
<tr><td colspan="1" align="left"> <p><b><font color="#00007f">添字と長さの演算: </font></b> </p></td></tr> 
<tr><td colspan="1" align="left"> <tt>xs(i)</tt> </td><td colspan="1" align="left"> (展開した場合，<tt>xs</tt> <tt>apply</tt> <tt>i</tt>)．<tt>xs</tt> の添字 <tt>i</tt> の位置の要素．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>isDefinedAt</tt> <tt>i</tt> </td><td colspan="1" align="left"> <tt>xs.indices</tt> に <tt>i</tt> が含まれているか調べる．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs.length</tt> </td><td colspan="1" align="left">シーケンスの長さ (<tt>size</tt> と同様)．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs.lengthCompare</tt> <tt>ys</tt> </td><td colspan="1" align="left"><tt>xs</tt> が <tt>ys</tt> より短い場合は <tt>-1</tt>，長い場合は <tt>+1</tt>，同じ長さの場合は <tt>0</tt> を返す．いずれかのシーケンスが無限でも正常に作動する．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs.indices</tt> </td><td colspan="1" align="left">0 から <tt>xs.length</tt> <tt>-</tt> <tt>1</tt> までの <tt>xs</tt> の添字の範囲．</td></tr> 
<tr><td colspan="1" align="left"> <p><b><font color="#00007f">添字検索演算: </font></b> </p></td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>indexOf</tt> <tt>x</tt> </td><td colspan="1" align="left"> <tt>xs</tt>内で <tt>x</tt> と等しい最初の要素の添字 (数種の別形がある) ． </td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>lastIndexOf</tt> <tt>x</tt> </td><td colspan="1" align="left"> <tt>xs</tt>内で <tt>x</tt> と等しい最後の要素の添字 (数種の別形がある) ． </td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>indexOfSlice</tt> <tt>ys</tt> </td><td colspan="1" align="left"><tt>xs</tt> の添字で，それと後続の要素が，シーケンス <tt>ys</tt> と同値になる最初のもの．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>lastIndexOfSlice</tt> <tt>ys</tt> </td><td colspan="1" align="left"><tt>xs</tt> の添字で，それと後続の要素が，シーケンス <tt>ys</tt> と同値になる最後のもの．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>indexWhere</tt> <tt>p</tt> </td><td colspan="1" align="left"> <tt>xs</tt>内で条件関数 <tt>p</tt> を満たす最初の要素の添字 (数種の別形がある) ． </td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>segmentLength</tt> <tt>(p,</tt> <tt>i)</tt> </td><td colspan="1" align="left">全ての要素が途切れなく条件関数 <tt>p</tt> を満たし，<tt>xs(i)</tt> から始まる，最長の <tt>xs</tt> の切片の長さ．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>prefixLength</tt> <tt>p</tt> </td><td colspan="1" align="left">全ての要素が途切れなく条件関数 <tt>p</tt> を満たす，最長の <tt>xs</tt> の先頭切片の長さ．</td></tr> 
<tr><td colspan="1" align="left"> <p><b><font color="#00007f">加算: </font></b> </p></td></tr> 
<tr><td colspan="1" align="left"> <tt>x</tt> <tt>+:</tt> <tt>xs</tt> </td><td colspan="1" align="left"><tt>xs</tt> の要素の先頭に <tt>x</tt> を追加した，新しいシーケンス．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>:+</tt> <tt>x</tt> </td><td colspan="1" align="left"><tt>xs</tt> の要素の最後に <tt>x</tt> を追加した，新しいシーケンス．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>padTo</tt> <tt>(len,</tt> <tt>x)</tt> </td><td colspan="1" align="left"><tt>xs</tt> の長さが <tt>len</tt> になるまで最後に値 <tt>x</tt> を追加していったシーケンス．</td></tr> 
<tr><td colspan="1" align="left"> <p><b><font color="#00007f">更新演算:</font></b> </p></td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>patch</tt> <tt>(i,</tt> <tt>ys,</tt> <tt>r)</tt> </td><td colspan="1" align="left"><tt>xs</tt>内の，<tt>i</tt> から始まる <tt>r</tt>個の要素をパッチ <tt>ys</tt>内の要素と置換したシーケンス．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>updated</tt> <tt>(i,</tt> <tt>x)</tt> </td><td colspan="1" align="left"><tt>xs</tt>の添字 <tt>i</tt> の要素を <tt>x</tt> と置換したコピー．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs(i)</tt> <tt>=</tt> <tt>x</tt> </td><td colspan="1" align="left"> (展開した場合，<tt>xs.update(i,</tt> <tt>x)</tt>，ただし可変シーケンスでのみ使用可能)． <tt>xs</tt>の添字 <tt>i</tt> の位置の要素を <tt>x</tt> と上書きする．</td></tr> 
<tr><td colspan="1" align="left"> <p><b><font color="#00007f">並べ替え演算:</font></b> </p></td></tr> 
<tr><td colspan="1" align="left"> <tt>xs.sorted</tt> </td><td colspan="1" align="left"><tt>xs</tt> の要素型の標準的な順序付けを用いて，<tt>xs</tt> の要素を並べ替えることによって得られる新しいシーケンス．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>sortWith</tt> <tt>lt</tt> </td><td colspan="1" align="left">比較関数 <tt>lt</tt> 用いて <tt>xs</tt> の要素を並べ替えることによって得られる新しいシーケンス．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>sortBy</tt> <tt>f</tt> </td><td colspan="1" align="left"> <tt>xs</tt> の要素を並べ替えることによって得られる新しいシーケンス．二つの要素の比較は，両者を関数 <tt>f</tt> に適用してその結果を比較することによって行われる．</td></tr> 
<tr><td colspan="1" align="left"> <p><b><font color="#00007f">逆転演算: </font></b> </p></td></tr> 
<tr><td colspan="1" align="left"> <tt>xs.reverse</tt> </td><td colspan="1" align="left"><tt>xs</tt>内の要素を逆順にしたシーケンス．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs.reverseIterator</tt> </td><td colspan="1" align="left"><tt>xs</tt>内の全ての要素を逆順に返すイテレータ．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>reverseMap</tt> <tt>f</tt> </td><td colspan="1" align="left"><tt>xs</tt>内の要素に逆順に関数 <tt>f</tt> を map して得られるシーケンス．</td></tr> 
<tr><td colspan="1" align="left"> <p><b><font color="#00007f">比較演算: </font></b> </p></td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>startsWith</tt> <tt>ys</tt> </td><td colspan="1" align="left"><tt>xs</tt> がシーケンス  <tt>ys</tt>  から始まるかを調べる (数種の別形がある)．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>endsWith</tt> <tt>ys</tt> </td><td colspan="1" align="left"><tt>xs</tt> がシーケンス  <tt>ys</tt>  で終わるかを調べる (数種の別形がある)．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>contains</tt> <tt>x</tt> </td><td colspan="1" align="left"><tt>xs</tt> が <tt>x</tt> と等しい要素を含むかを調べる．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>containsSlice</tt> <tt>ys</tt> </td><td colspan="1" align="left"><tt>xs</tt> が <tt>ys</tt> と等しい連続した切片を含むかを調べる．</td></tr> 
<tr><td colspan="1" align="left"> <tt>(xs</tt> <tt>corresponds</tt> <tt>ys)(p)</tt> </td><td colspan="1" align="left"><tt>xs</tt> と <tt>ys</tt> の対応した要素が，二項条件関数の <tt>p</tt> を満たすかを調べる．</td></tr> 
<tr><td colspan="1" align="left"> <p><b><font color="#00007f">集合演算: </font></b> </p></td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>intersect</tt> <tt>ys</tt> </td><td colspan="1" align="left">シーケンス <tt>xs</tt> と <tt>ys</tt> の積集合で，<tt>xs</tt> における要素の順序を保ったもの．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>diff</tt> <tt>ys</tt> </td><td colspan="1" align="left">シーケンス <tt>xs</tt> と <tt>ys</tt> の差集合で，<tt>xs</tt> における要素の順序を保ったもの．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs</tt> <tt>union</tt> <tt>ys</tt> </td><td colspan="1" align="left">和集合; <tt>xs</tt> <tt>++</tt> <tt>ys</tt> に同じ．</td></tr> 
<tr><td colspan="1" align="left"> <tt>xs.distinct</tt> </td><td colspan="1" align="left"><tt>xs</tt> の部分シーケンスで要素の重複を一切含まないもの．</td></tr></tbody></table> 

<p>trait <a href="http://www.scala-lang.org/api/current/scala/collection/Seq.html">Seq</a> には <a href="http://www.scala-lang.org/api/current/scala/collection/LinearSeq.html">LinearSeq</a> と <a href="http://www.scala-lang.org/api/current/scala/collection/IndexedSeq.html">IndexedSeq</a> という二つの subtrait がある．これらは新しい演算を定義しないが，それぞれ異なった性能特性をもつ．線形シーケンス (linear sequence) は効率的な <tt>head</tt> と <tt>tail</tt> 演算を持ち，一方添字付きシーケンス (indexed sequence) は効率的な<tt>apply</tt>．<tt>length</tt>，および (可変の場合) <tt>update</tt> 演算を持つ．よく使われる線形シーケンスの例に  <tt>scala.collection.immutable.List</tt> と <tt>scala.collection.immutable.Stream</tt> がある．よく使われる添字付きシーケンスの例としては <tt>scala.Array</tt> と <tt>scala.collection.mutable.ArrayBuffer</tt> がある．<tt>Vector</tt> は添字付きシーケンスと線形シーケンスの間の興味深い折衷案だ．事実上定数時間のオーバーヘッドで添字アクセスと線形アクセスを提供するからだ．そのため，ベクトルは添字アクセスと線形アクセスの両方を混合して使用してるアクセスパターンにおける良い基盤となる．ベクトルに関しては，また<a href="collections_15.html">後ほど</a>． 
<p>次へ:<ul> <li><a href="collections_6.html">バッファ</a> </li></ul> <hr> 
<table width="100%" cellpadding="0" cellspacing="2"><tr> <td bgcolor="#99ccff"><a href="collections_7.html"><img border="0" alt="Set" src="http://lampwww.epfl.ch/~odersky/images/next.png"></a></td><td bgcolor="#99ccff"><a href="collections_0.html"><img border="0" alt="トップ" src="http://lampwww.epfl.ch/~odersky/images/up.png"></a></td><td bgcolor="#99ccff"><a href="collections_4.html"><img border="0" alt="Trait Iterable" src="http://lampwww.epfl.ch/~odersky/images/previous.png"></a></td><td align="center" bgcolor="#99ccff" width="100%"><b>シーケンスの trait Seq, IndexedSeq, および LinearSeq</b></td><td bgcolor="#99ccff" align="center"><a href="collections_49.html">Contents</a></td></tr></table>
</body></html>